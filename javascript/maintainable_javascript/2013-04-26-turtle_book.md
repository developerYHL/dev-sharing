- Date: 2013-09-02 16:14:31

프로그래밍 기법
================

UI 인터페이스 층위 분리하기
----------------------------

사용자 인터페이스의 세 층위

- JavaScript: 페이지의 동작
- CSS: 겉모습
- HTML: 데이터와 의미

세 층위를 되도록 느슨하게 연결해야 한다. 즉 세 층위는 서로 딱 알만큼만 알아야 한다. 그래야 필요한만큼만 영향을 주고 받고, 문제가 발생하면 어디에서 문제가 발생했는지 알기 쉬워진다. 

### CSS에서 자바스크립트의 분리 ###

`expression()` 프로퍼티는 성능을 떨어뜨릴 뿐만 아니라, 문제가 발생하면 누구의 책임인지 알아내기 어려워진다. 

	// 하지마라
	.box { width: expression(document.body.offsetWidth + "px"); }

### 자바스크립트에서 CSS 분리 ###

자바스크립트에서 CSS 프로퍼티를 직접 수정하지 않는다(위치 이동하거나 크기를 조절하는 경우는 예외. 가령 애니메이션). 그렇지 않으면 페이지의 겉모습에서 생긴 문제를 해결하기 위해 자바스크립트와 CSS 둘 다를 들여다봐야 한다. 자바스크립트는 클래스를 뗐다 붙였다 하는 식으로 CSS와 소통해야 한다.

	// 하지마라
	element.style.cssText = "color: red";
	element.style.color = "red";

### HTML에서 자바스크립트 분리하기 ###

"onclick"과 같은 "on-" 어트리뷰트에서 함수를 호출해선 안된다. 이벤트 핸들러가 요소보다 나중에 정의되면 문제가 생긴다. 그리고 호출되는 함수의 이름을 바꾸거나, 다른 이벤트 핸들러를 할당할 때 HTML을 변경해야 한다. 그러므로 이벤트 핸들러는 스크립트에서 할당해야 한다.

	<!-- 하지마라 -->
	<button onclick="doit()" />

`<script>` 요소에 스크립트를 직접 쓰지도 마라.

### 자바스크립트에서 HTML 분리하기 ###

둘을 분리하지 않으면 마크업을 수정할 때 자바스크립트와 HTML을 둘 다 봐야 한다. 더군다나 텍스트 노드나 어트리뷰트 값 등은 이스케이프를 해야하므로 html 요소 문자열을 자바스크립트로 직접 처리하면 일이 복잡해진다. 

- AJAX로 서버에게 마크업을 요청하는 방법
- 클라이언트 측에서 템플릿을 쓰는 방법

#### 간단한 템플릿 ####

HTML:

	<ul id="list"><!--<li id="item%s"><a href="%s">%s</a></li>-->
	</ul>

Javascript:

	function sprintf (text) {
		var i = 1, args = arguments;
		return text.replace(/%s/g, function () {
			return (i < args.length) ? args[i++] : "";
		});
	}
	function addItem (id, url, text) {
		var template = document.getElementById('list').firstChild.nodeValue,
		    result   = sprintf(template, id, url, text);
		$('#list').append(result);
	}

	...
	addItem('1','/1','item1');
	addItem('2','/2','item2');
	addItem('3','/3','item3');

결과:

	<ul id='list'><!--<li id="item%s"><a href="%s">%s</a></li>-->
		<li id="item1"><a href="/1">item 1</a></li>
		<li id="item2"><a href="/2">item 2</a></li>
		<li id="item3"><a href="/3">item 3</a></li>
	</ul>

- `sprintf()`의 용법은 다음과 같다:
	
		sprintf('안녕 %s? 내 이름은 %s야.','토끼야','거북이');

   결과는 다음과 같다. 

		안녕 토끼야? 내 이름은 거북이야

- arguments 객체는 함수 실행 맥락이 시작되면서 생성되는 객체이며, 넘겨받은 인수들을 담고 있다. 

전역 선언 방지
---------------

자바스크립트가 실행되면 전역 객체가 생겨서 여기에 모든 스크립트 세상의 삼라 만상이 다 들어간다. 브라우저에서는 `window`가 바로 그런 객체다. 전역으로 선언한 변수와 함수는 이 객체의 프로퍼티로 들어간다. 

### 전역의 문제점 ###

- 이름 공간의 오염으로 인한 이름 충돌
- 함수들이 전역 변수에 의존한 경우 전역 변수를 변경할 경우 어디에서 무슨 일이 벌어질지 예측하기 어려워진다. 
- 전역 변수를 사용하는 함수를 제대로 테스트하려면, 실제 전역 환경과 테스트 환경을 맞춰야 한다. 즉 테스트용 환경과 실제 환경을 다 구축해야 하고, 둘이 차이가 나지 않도록 동기화해야 한다.

### 전역을 피하는 방법 ###

- 변수 선언시 언제나 `var`를 쓴다. 
- 객체를 하나 만들어서 관련된 코드를 거기에 몰아넣기
- 그 객체 안에서도 관련된 코드를 객체의 프로퍼티로 묶어두기
- 모듈
- 바로 호출되는 익명 함수를 쓴다: 다른 스크립트와 상호작용이 전혀 없는 경우 가능.

이벤트 처리
------------

이벤트를 처리할 때에는 이벤트 핸들러의 동작을 분리해야 한다. 그래서 해당 함수를 호출하는 것만으로도 그 동작을 일으킬 수 있도록 해야 한다. 그렇게 하면 그 동작을 재사용할 수도 있고, 테스트를 하기 위해 매번 직접 이벤트를 발생시키지 않아도 된다. 

한편 이벤트를 처리할 때는 이벤트 객체의 극히 일부만을 사용한다. 그러므로 이벤트 핸들러의 동작을 일으키는 함수에게는 이벤트 객체가 아니라, 이벤트 객체에서 사용할 프로퍼티를 인자로 넘겨야 한다. 그렇게 하면 이벤트 객체를 생성하지 않고도 동작을 재사용할 수 있고, 인터페이스도 더 이해하기 쉬워진다. 

	function(event) {
		event.clientX ... 
		event.clientY ...
	}

가 아니라

	function(x, y) { ... }

로 선언하고 

	function(event.clientX,event.clientY);

로 호출해야한다.

한편 버블링은 막아서 이벤트 핸들러 하나만 작동하게 하는게 좋다.

	event.preventDefault();
	event.stopPropagation();

`null` 비교 금지
----------------

인자로 넘겨받은 값이 제대로 된 것인지 확인하려면, 넘겨받은 값을 `null`과 비교해서는 안된다. 예를 들어 배열을 넘겨받을 때만 제대로 작동하는 함수를 만들 경우, 넘겨받은 인자가 문제 없는 놈인지 확인한답시고, 인자를 `null`과 비교해서는 안된다는 것이다. 

`typeof` 연산자를 사용하면 기본 데이터 타입을 알아낼 수 있다. `typeof` 연산자가 반환하는 자바스크립트의 기본 데이터 타입은 다음과 같다

- `string`
- `number`
- `boolean`
- `undefined`

`typeof`는 연산자이므로 되도록 괄호를 쓰지 않는다. 

진짜로 `null`인지 아닌지를 검사하는 경우에는 `typeof` 연산자를 쓰면 안된다. `typeof` 연산자는 `null`에 대해 `object`를 돌려주기 때문이다. 그러므로 `===`나 `!==`를 사용해야 한다. 

### 객초 참조 타입 알아내기 ###

기본 데이터 타입을 제외한 모든 값은 참조(`reference`)다. 참조는 다른 값을 가리키는 값이다. 

사용자 정의 객체의 경우 `typeof` 연산자는 어떤 생성자로 생성했든지 간에 모두 `object`를 돌려주기 때문에 쓸모가 없다. 생성자를 알아내서 객체의 프로토타입을 알아내려면 `instanceof`라는 이항 연산자를 쓴다. 용법은: 

	값 instanceof 생성자명

`instanceof` 연산자는 상속받은 프로토타입도 같이 검사한다. 

프레임을 사용할 경우 `instanceof` 연산자는 해당 프레임에서 생성된 것인지를 검사하므로, 객체를 다른 프레임으로 넘기면, 다른 프레임에도 똑같은 생성자가 있다고 하더라도 `false`가 나올 수 밖에 없다. `function`과 `array`를 넘길 대도 마찬가지다. 

### 함수인지 알아내기 ###

함수의 경우 `Function`이라는 생성자가 프레임 별로 따로 있어서 다른 프레임으로 넘기면 `instanceof`로 검사하면 `false`가 나온다. 이런 일을 피하려면 `typeof` 연산자를 쓰면 된다. `typeof` 연산자는 함수에 대해서 언제나 `function`을 돌려주기 때문이다. 

다만 IE8 이하에서는 `typeof` 연산자는 DOM의 메서드에 대해 `object`를 돌려준다. 그러므로 하위 호환성을 위해 DOM의 메서드가 존재하는지 확인하려면 `in` 연산자를 이용한다. 

	if ("querySelectorAll" in document) { ... }

### 배열인지 알아내기 ###

배열도 함수처럼 다른 프레임으로 넘기면, `instaceof`로 검사해도 배열이 아니라고 나온다. 그래서 더글라스 크록포드가 제안한 판별법은 다음과 같다. 

	function isArray(value) { return typeof value.sort === "function" }

위와 같은 기법을 오리 타이핑(duck-typing)이라고 한다. 오리 타이핑은 객체의 상속이나 클래스가 아니라 객체가 가진 메서드와 프로퍼티로 객체를 규정하는 스타일을 말한다. 이 용어는 제임스 위트콤 라일리라는 작가의 비유에서 나온 말이다.

> 오리처럼 헤엄치고, 오리처럼 꽥꽥대는 새가 있으면 그게 바로 오리다.

그러나 오리처럼 헤엄치고, 오리처럼 꽥꽥된다고 다 오리인 것은 아니고, 이것이 덕타이핑의 약점이다. 크록포드의 방법을 쓰면 꼭 배열이 아니어도 메서드 중에 `sort`가 있으면 배열로 판별된다. 

유리 자이체프는 다음과 같은 해결책을 제시한다. 

	function isArray(value) {
		return Object.prototype.toString.call(value) === "[object Array]"
	}

향후 ECMAScript5 스펙에는 `isArray` 메서드가 추가된다고 하니 좋은 소식이다. 

### 프로퍼티 알아내기 ###

프로퍼티 값을 직접 검사했다간 피를 볼 수도 있다. 프로퍼티 값 자체가 0이거나 `false`일 수도 있기 때문이다. 그러므로 `in` 연산자를 쓴다. 

`hasOwnProperty()`는 인스턴스의 프로퍼티인지 검사한다. 